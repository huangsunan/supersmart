#!/usr/bin/perl
use strict;
use warnings;
use lib 'lib';
use ExtUtils::MakeMaker;

WriteMakefile(
	'NAME'          => 'Bio::SUPERSMART',
	'ABSTRACT_FROM' => 'lib/Bio/SUPERSMART.pm',
	'VERSION_FROM'  => 'lib/Bio/SUPERSMART.pm',
	'AUTHOR'        => 'http://www.supersmart-project.org/#people',
	'LICENSE'       => 'mit',	
	'PREREQ_PM' => {
		'DBIx::Class'           => 0,
		'DBI'                   => 0,
		'DBD::mysql'            => 0,
		'Template'              => 0,
		'Config::Tiny'          => 0,
		'Moose'                 => 0,
		'XML::Twig'             => 0,
		'HTML::Parser'          => 0,
		'JSON'                  => 0,
		'Math::Random'          => 0,
		'App::Cmd'              => 0,
		'String::RewritePrefix' => 0,
		'IO::String'            => 0,
		'Statistics::R'         => 0,
		'Parallel::ForkManager' => 0,
		# 'Parallel::MPI::Simple' => 0,
		
		# XXX would be good if there was some way to define a dependency on
		# git repositories such that `cpanm --installdeps .` would be able
		# to pick it up. Doesn't work here, but maybe in the extended
		# meta merge stuff?
		# 'BioPerl'               => 0,
		# 'BioPerl-Run'           => 0,
		# 'Bio::Phylo'            => 0, 
	}
);

package MY;
use FindBin '$Bin';

sub postamble {
	my $package = shift;
	
	# setup the vagrant environment
	my $result = _setup_commands();
	
	# read shell install commands from .travis.yml and inject into vagrant
	my @commands = _install_commands();
	$result .= join '', 
	            map { "\t\$(VAGRANT) \$(INJECT) \$(WD) $_ \$(DONE)\n" } 
	            map { /cpanm/ ? "sudo $_" : $_ }
	           grep { $_ !~ /vagrant/ } @commands;
	
	# run unit tests and package the box
	require Bio::SUPERSMART;
	$result .= <<"PACKAGE";
	\$(VAGRANT) box repackage naturalis/supersmart virtualbox $Bio::SUPERSMART::VERSION
PACKAGE
		
	# finally, remove the Vagrantfile and destroy the box again
	$result .= "\t\$(RM_RF) Vagrantfile .vagrant\n";
	return $result;
}

sub _setup_commands {
	return <<'SETUP';
# This target is generated by MY::postamble to create
# a new vagrant box for upload to the vagrant cloud.
# The box is built on top of plain ubuntu 14.04LTS. Many
# of the directives that end up in this target are parsed
# out of the 'install:' section in .travis.yml

# alias for the vagrant command:
VAGRANT=vagrant

# aliases to inject commands into an instance using ssh -c
INJECT=ssh -c '
DONE='
WD=cd supersmart &&
GREP=grep

vagrant:
	$(RM_RF) Vagrantfile .vagrant
	$(VAGRANT) init ubuntu/trusty64
	$(NOECHO) $(GREP) -v '^end' Vagrantfile > Vagrantfile.patched
	$(NOECHO) $(ECHO) '  config.vm.provider "virtualbox" do |v|' >> Vagrantfile.patched
	$(NOECHO) $(ECHO) '    v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]' >> Vagrantfile.patched
	$(NOECHO) $(ECHO) '    v.customize ["modifyvm", :id, "--natdnsproxy1", "on"]' >> Vagrantfile.patched
	$(NOECHO) $(ECHO) '  end' >> Vagrantfile.patched
	$(NOECHO) $(ECHO) 'end' >> Vagrantfile.patched
	$(NOECHO) $(MV) Vagrantfile.patched Vagrantfile
	$(VAGRANT) up	
	$(VAGRANT) $(INJECT) wget -O - https://cpanmin.us | sudo perl - App::cpanminus $(DONE)
	$(VAGRANT) $(INJECT) sudo apt-get install -y git $(DONE)
	$(VAGRANT) $(INJECT) git clone https://github.com/naturalis/supersmart.git $(DONE)
SETUP
}


sub _install_commands {
	my $package = shift;
	my $travis_yml = "${Bin}/.travis.yml";
	my ( @commands, $install_seen );
	open my $fh, '<', $travis_yml or die $!;
	LINE: while(<$fh>) {
		chomp;
		if ( /^install:\s*$/ ) {
			$install_seen++;
			next LINE;
		}
		if ( $install_seen and /^\s*-\s*"(.+)"\s*$/ ) {
			my $command = $1;
			push @commands, $command;
		}
	}
	return @commands;
}

