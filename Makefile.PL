#!/usr/bin/perl
use strict;
use warnings;
use lib 'lib';
use ExtUtils::MakeMaker;

WriteMakefile(
	'NAME'          => 'Bio::SUPERSMART',
	'ABSTRACT_FROM' => 'lib/Bio/SUPERSMART.pm',
	'VERSION_FROM'  => 'lib/Bio/SUPERSMART.pm',
	'AUTHOR'        => 'http://www.supersmart-project.org/#people',
	'LICENSE'       => 'mit',	
	'PREREQ_PM' => {
		'DBIx::Class'           => 0,
		'DBI'                   => 0,
		'DBD::mysql'            => 0,
		'Template'              => 0,
		'Config::Tiny'          => 0,
		'Moose'                 => 0,
		'XML::Twig'             => 0,
		'HTML::Parser'          => 0,
		'JSON'                  => 0,
		'Math::Random'          => 0,
		'App::Cmd'              => 0,
		'String::RewritePrefix' => 0,
		'IO::String'            => 0,
		'Statistics::R'         => 0,
		'Parallel::ForkManager' => 0,
		# 'Parallel::MPI::Simple' => 0,
		
		# XXX would be good if there was some way to define a dependency on
		# git repositories such that `cpanm --installdeps .` would be able
		# to pick it up. Doesn't work here, but maybe in the extended
		# meta merge stuff?
		# 'BioPerl'               => 0,
		# 'BioPerl-Run'           => 0,
		# 'Bio::Phylo'            => 0, 
	}
);

package MY;
use FindBin '$Bin';

sub postamble {
	my $package = shift;
	
	# setup the vagrant environment
	my $result = _setup_commands();
	
	# read shell install commands from .travis.yml and inject into vagrant
	my @commands = _install_commands();
	$result .= "vagrant_install: vagrant_setup\n" . join '', 
	            map { "\t\$(VAGRANT) \$(INJECT) \$(WD) $_ \$(DONE)\n" } 
	            map { /cpanm/ ? "sudo $_" : $_ }
	           grep { $_ !~ /vagrant/ } @commands;
	
	# clean up and package the box
	$result .= <<'PACKAGE';

vagrant_shrink: vagrant_install
	$(VAGRANT) $(INJECT) sudo apt-get clean $(DONE)
	$(VAGRANT) $(INJECT) sudo rm -rf ~/supersmart $(DONE)
	$(VAGRANT) $(INJECT) sudo rm -f /EMPTY $(DONE)
	$(VAGRANT) $(INJECT) cat /dev/null > ~/.bash_history && history -c && exit $(DONE)

supersmart.box: vagrant_shrink
	$(VAGRANT) package --output $@

vagrant_clean:
	$(VAGRANT) destroy -f
	$(RM_RF) Vagrantfile .vagrant
PACKAGE
		
	return $result;
}

sub _setup_commands {
	return <<'SETUP';
# These targets are generated by MY::postamble to create
# a new vagrant box for upload to the vagrant cloud.
# The box is built on top of plain ubuntu 14.04LTS. Many
# of the directives that end up in this target are parsed
# out of the 'install:' section in .travis.yml

# alias for the vagrant command:
VAGRANT=vagrant

# aliases to inject commands into an instance using ssh -c
INJECT=ssh -c '
DONE='
WD=cd supersmart &&

# alias for patching the Vagrantfile
PATCH=patch

Vagrantfile:
	$(RM_RF) Vagrantfile .vagrant
	$(VAGRANT) init ubuntu/trusty64
	$(PATCH) $@ Vagrantfile.patch

vagrant_setup: Vagrantfile
	$(VAGRANT) up
	$(VAGRANT) $(INJECT) wget -O - https://cpanmin.us | sudo perl - App::cpanminus $(DONE)
	$(VAGRANT) $(INJECT) sudo apt-get install -y git $(DONE)
	$(VAGRANT) $(INJECT) git clone https://github.com/naturalis/supersmart.git $(DONE)

SETUP
}


sub _install_commands {
	my $package = shift;
	my $travis_yml = "${Bin}/.travis.yml";
	my ( @commands, $install_seen );
	open my $fh, '<', $travis_yml or die $!;
	LINE: while(<$fh>) {
		chomp;
		if ( /^install:\s*$/ ) {
			$install_seen++;
			next LINE;
		}
		if ( $install_seen and /^\s*-\s*"(.+)"\s*$/ ) {
			my $command = $1;
			push @commands, $command;
		}
	}
	return @commands;
}

